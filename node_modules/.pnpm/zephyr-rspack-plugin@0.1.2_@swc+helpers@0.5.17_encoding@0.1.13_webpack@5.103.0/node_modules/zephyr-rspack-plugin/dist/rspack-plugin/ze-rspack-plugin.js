"use strict";
var _ZeRspackPlugin_instances, _ZeRspackPlugin_convertFederatedDepsToRemotes, _ZeRspackPlugin_injectImportMapAtBuildTime;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZeRspackPlugin = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@rspack/core");
const zephyr_agent_1 = require("zephyr-agent");
const zephyr_xpack_internal_1 = require("zephyr-xpack-internal");
const pluginName = 'ZeRspackPlugin';
class ZeRspackPlugin {
    constructor(options) {
        _ZeRspackPlugin_instances.add(this);
        this._options = Object.assign({ pluginName }, options);
    }
    apply(compiler) {
        this._options.zephyr_engine.buildProperties.output = compiler.outputPath;
        (0, zephyr_xpack_internal_1.detectAndStoreBaseHref)(this._options.zephyr_engine, compiler);
        (0, zephyr_xpack_internal_1.logBuildSteps)(this._options, compiler);
        (0, zephyr_xpack_internal_1.setupManifestEmission)(this._options, compiler);
        (0, zephyr_xpack_internal_1.setupZeDeploy)(this._options, compiler);
        // Inject import map into HTML at build time for consistent structure
        tslib_1.__classPrivateFieldGet(this, _ZeRspackPlugin_instances, "m", _ZeRspackPlugin_injectImportMapAtBuildTime).call(this, compiler);
        // Ensure our loader runs on JS/TS to rewrite env reads to virtual module
        const rules = compiler.options?.module?.rules || [];
        rules.unshift({
            test: /\.[jt]sx?$/,
            exclude: /node_modules/,
            use: [
                {
                    loader: require.resolve('./env-virtual-loader.js'),
                    options: {
                        specifier: `env:vars:${this._options.zephyr_engine.application_uid}`,
                    },
                },
            ],
        });
        compiler.options.module = compiler.options.module || {};
        compiler.options.module.rules = rules;
        // Mark the virtual specifier external so import maps can resolve it
        const existingExternals = compiler.options?.externals;
        const PER_APP_SPECIFIER = `env:vars:${this._options.zephyr_engine.application_uid}`;
        const virtualExternal = {
            [PER_APP_SPECIFIER]: `module ${PER_APP_SPECIFIER}`,
        };
        if (!existingExternals) {
            compiler.options.externals = virtualExternal;
        }
        else if (Array.isArray(existingExternals)) {
            compiler.options.externals = [...existingExternals, virtualExternal];
        }
        else if (typeof existingExternals === 'object') {
            compiler.options.externals = {
                ...existingExternals,
                ...virtualExternal,
            };
        } // function externals not supported here; users can extend if needed
    }
}
exports.ZeRspackPlugin = ZeRspackPlugin;
_ZeRspackPlugin_instances = new WeakSet(), _ZeRspackPlugin_convertFederatedDepsToRemotes = function _ZeRspackPlugin_convertFederatedDepsToRemotes() {
    return (this._options.zephyr_engine.federated_dependencies?.map((dep) => ({
        name: dep.name,
        application_uid: dep.application_uid,
        remote_entry_url: dep.default_url,
    })) || []);
}, _ZeRspackPlugin_injectImportMapAtBuildTime = function _ZeRspackPlugin_injectImportMapAtBuildTime(compiler) {
    compiler.hooks.compilation.tap(pluginName, (compilation) => {
        // Use HtmlRspackPlugin's proper hooks
        try {
            const hooks = core_1.HtmlRspackPlugin.getCompilationHooks(compilation);
            // Use afterTemplateExecution hook to modify HTML and tags
            hooks.afterTemplateExecution.tapPromise(pluginName, async (data) => {
                try {
                    const appUid = this._options.zephyr_engine.application_uid;
                    const remotes = tslib_1.__classPrivateFieldGet(this, _ZeRspackPlugin_instances, "m", _ZeRspackPlugin_convertFederatedDepsToRemotes).call(this);
                    // Check if import map already exists
                    const hasImportMap = data.headTags.some((tag) => tag.tagName === 'script' && tag.attributes?.type === 'importmap');
                    if (!hasImportMap) {
                        // Add import map to head tags
                        data.headTags.unshift({
                            tagName: 'script',
                            attributes: { type: 'importmap' },
                            innerHTML: JSON.stringify({
                                imports: (0, zephyr_agent_1.buildEnvImportMap)(appUid, remotes),
                            }),
                            voidTag: false,
                        });
                    }
                }
                catch (e) {
                    zephyr_agent_1.ze_log.misc('Failed to inject import map at build time:', e);
                }
                return data;
            });
        }
        catch {
            // HtmlRspackPlugin might not be available if no HTML is being generated
            zephyr_agent_1.ze_log.misc('HtmlRspackPlugin not available, skipping import map injection');
        }
    });
};
//# sourceMappingURL=ze-rspack-plugin.js.map