"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchWithRetries = fetchWithRetries;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importStar(require("axios"));
const axios_retry_1 = tslib_1.__importDefault(require("axios-retry"));
const is_ci_1 = tslib_1.__importDefault(require("is-ci"));
const errors_1 = require("../errors");
const IPV4_FAMILY = 4;
const RETRY_ERROR_CODES = [
    'ETIMEDOUT',
    'ENETUNREACH',
    'ECONNRESET',
    'ECONNREFUSED',
    'EPIPE',
];
function shouldRetry(error) {
    // Retry on network errors (no response received)
    if (!error.response) {
        const code = error.code;
        const message = error.message || '';
        return ((code && RETRY_ERROR_CODES.includes(code)) ||
            message.includes('network') ||
            message.includes('timeout'));
    }
    // Retry on server errors (5xx)
    return error.response.status >= 500;
}
async function fetchWithRetries(url, options = {}, retries = 3) {
    var _a, _b, _c, _d, _e;
    try {
        // Create a custom axios instance for this request with CI-friendly settings
        const axiosInstance = axios_1.default.create({
            // Force IPv4 in CI environments to avoid IPv6 connectivity issues
            // References: https://github.com/actions/runner/issues/3138
            // https://x.com/matteocollina/status/1640384245834055680
            family: is_ci_1.default ? IPV4_FAMILY : undefined,
        });
        // Configure axios-retry
        (0, axios_retry_1.default)(axiosInstance, {
            retries,
            retryDelay: axios_retry_1.default.exponentialDelay,
            retryCondition: shouldRetry,
        });
        // Convert fetch options to axios options
        const axiosConfig = Object.assign({ method: (_a = options.method) !== null && _a !== void 0 ? _a : 'GET', data: options.body }, (options.signal ? { signal: options.signal } : {}));
        if (options.headers) {
            // Convert HeadersInit to a format compatible with axios headers
            if (options.headers instanceof Headers) {
                // Convert Headers object to record
                const headersRecord = {};
                options.headers.forEach((value, key) => {
                    headersRecord[key] = value;
                });
                axiosConfig.headers = headersRecord;
            }
            else if (Array.isArray(options.headers)) {
                // Convert header entries array to record
                const headersRecord = {};
                options.headers.forEach(([key, value]) => {
                    headersRecord[key] = value;
                });
                axiosConfig.headers = headersRecord;
            }
            else {
                // Already a record object
                axiosConfig.headers = options.headers;
            }
        }
        // Make the request with retries
        const response = await axiosInstance(url.toString(), axiosConfig);
        // Convert axios response to fetch Response interface
        return {
            ok: response.status >= 200 && response.status < 300,
            status: response.status,
            headers: new Headers(Object.entries(response.headers).reduce((acc, [key, value]) => {
                if (value !== undefined) {
                    acc[key] = typeof value === 'string' ? value : String(value);
                }
                return acc;
            }, {})),
            text: async () => typeof response.data === 'string'
                ? response.data
                : JSON.stringify(response.data) || '',
            json: async () => response.data,
        };
    }
    catch (error) {
        // Handle errors after all retries have been exhausted
        if (error instanceof axios_1.AxiosError && error.response) {
            // Client errors (4xx)
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_HTTP_ERROR, {
                status: error.response.status,
                url: url.toString(),
                content: error.response.data,
                method: (_c = (_b = options.method) === null || _b === void 0 ? void 0 : _b.toUpperCase()) !== null && _c !== void 0 ? _c : 'GET',
            });
        }
        // Unknown errors
        if (error instanceof axios_1.AxiosError &&
            (error.code === 'EPIPE' || (error.message && error.message.includes('network')))) {
            // Max retries reached for network error
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_HTTP_ERROR, {
                status: -1,
                url: url.toString(),
                content: 'Max retries reached for network error',
                method: (_e = (_d = options.method) === null || _d === void 0 ? void 0 : _d.toUpperCase()) !== null && _e !== void 0 ? _e : 'GET',
            });
        }
        // Other unknown errors
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_UNKNOWN, {
            message: 'Unknown error occurred',
            cause: error,
        });
    }
}
//# sourceMappingURL=fetch-with-retries.js.map