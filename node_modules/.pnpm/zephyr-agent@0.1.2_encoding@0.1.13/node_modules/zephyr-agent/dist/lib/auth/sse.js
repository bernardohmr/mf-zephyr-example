"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthListener = void 0;
const eventsource_1 = require("eventsource");
const logging_1 = require("../logging");
const errors_1 = require("../errors");
class AuthListener {
    constructor(workerUrl) {
        workerUrl.pathname = '/sse';
        this.workerUrl = workerUrl;
    }
    async waitForToken(timeoutMs = 5 * 60 * 1000) {
        const sessionId = this.workerUrl.searchParams.get('sessionId');
        if (!sessionId) {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_UNKNOWN, {
                message: 'Session ID is required',
            });
        }
        return new Promise((resolve, reject) => {
            const eventSource = new eventsource_1.EventSource(this.workerUrl);
            const timeout = setTimeout(() => {
                eventSource.close();
                reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_UNKNOWN, {
                    message: 'Auth timeout',
                }));
            }, timeoutMs);
            eventSource.onmessage = (event) => {
                var _a, _b;
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'token') {
                        clearTimeout(timeout);
                        eventSource.close();
                        const token = (_a = data.token) !== null && _a !== void 0 ? _a : (_b = data.tokens) === null || _b === void 0 ? void 0 : _b.access_token;
                        resolve({ sessionId, token });
                    }
                    else if (data.type === 'error') {
                        clearTimeout(timeout);
                        eventSource.close();
                        reject(new Error(data.message));
                    }
                    else {
                        (0, logging_1.ze_debug)('AuthListener', `Unknown message type: ${data.type}`);
                    }
                }
                catch (err) {
                    clearTimeout(timeout);
                    eventSource.close();
                    reject(err);
                }
            };
            eventSource.onerror = (error) => {
                clearTimeout(timeout);
                eventSource.close();
                reject(error);
            };
        });
    }
}
exports.AuthListener = AuthListener;
//# sourceMappingURL=sse.js.map