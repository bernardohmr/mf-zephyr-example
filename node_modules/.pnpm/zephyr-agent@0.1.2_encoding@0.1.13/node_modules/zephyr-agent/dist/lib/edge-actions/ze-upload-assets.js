"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zeUploadAssets = zeUploadAssets;
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const upload_file_1 = require("../http/upload-file");
const logging_1 = require("../logging");
const picocolor_1 = require("../logging/picocolor");
const get_application_hash_list_1 = require("../edge-requests/get-application-hash-list");
const get_missing_assets_1 = require("../edge-hash-list/get-missing-assets");
const CLOUDFLARE_BATCH_SIZE = 6;
async function zeUploadAssets(zephyr_engine, { missingAssets, assetsMap }) {
    const count = Object.keys(assetsMap).length;
    const logger = await zephyr_engine.logger;
    const appConfig = await zephyr_engine.application_configuration;
    const envs = appConfig.ENVIRONMENTS;
    if (envs != null) {
        await Promise.all(Object.entries(envs)
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            .filter(([_, envCfg]) => envCfg.edgeUrl !== appConfig.EDGE_URL)
            .map(([env, envCfg]) => zeUploadAssetsForEnv(env, envCfg, appConfig, assetsMap)));
    }
    if (missingAssets.length === 0) {
        logger({
            level: 'info',
            action: 'snapshot:assets:upload:empty',
            message: `No assets to upload, ${(0, picocolor_1.white)('skipping')}...`,
        });
        return true;
    }
    const start = Date.now();
    let totalSize = 0;
    // If the target is iOS or Android, we upload the assets in a 6 request batch to avoid cloudflare worker requests limit
    // Reference: https://developers.cloudflare.com/workers/platform/limits/#simultaneous-open-connections:~:text=Once%20an%20invocation%20has%20six%20connections%20open%2C%20it%20can%20still%20attempt%20to%20open%20additional%20connections.
    if (zephyr_engine.env.target !== 'ios' && zephyr_engine.env.target !== 'android') {
        await Promise.all(missingAssets.map(upload_missing_asset));
    }
    else {
        logging_1.ze_log.upload("The target platform is 'ios' and 'android' so we are switching to batch upload.");
        await (0, zephyr_edge_contract_1.forEachLimit)(missingAssets.map((asset) => () => upload_missing_asset(asset)), CLOUDFLARE_BATCH_SIZE);
    }
    logger({
        level: 'info',
        action: 'snapshot:assets:upload:done',
        message: (0, picocolor_1.white)(`(${(0, picocolor_1.whiteBright)(missingAssets.length.toString())}/${(0, picocolor_1.white)(count.toString())} assets uploaded in ${(0, picocolor_1.whiteBright)((Date.now() - start).toString())}ms, ${(0, picocolor_1.whiteBright)(totalSize.toFixed(2))}kb)`),
    });
    return true;
    async function upload_missing_asset(asset) {
        var _a;
        const start = Date.now();
        const assetWithBuffer = assetsMap[asset.hash];
        const assetSize = ((_a = assetWithBuffer === null || assetWithBuffer === void 0 ? void 0 : assetWithBuffer.buffer) === null || _a === void 0 ? void 0 : _a.length) / 1024;
        await (0, upload_file_1.uploadFile)({
            hash: asset.hash,
            asset: assetWithBuffer,
        }, appConfig);
        const fileUploaded = Date.now() - start;
        totalSize += assetSize;
        logging_1.ze_log.upload(`file ${asset.path} uploaded in ${fileUploaded}ms (${assetSize.toFixed(2)}kb)`);
    }
    async function zeUploadAssetsForEnv(env, envCfg, appConfig, assetsMap) {
        const hash_set = await (0, get_application_hash_list_1.getApplicationHashList)({
            application_uid: zephyr_engine.application_uid,
            edge_url: envCfg.edgeUrl,
        });
        const missingAssets = (0, get_missing_assets_1.get_missing_assets)({
            assetsMap,
            hash_set: { hash_set: new Set(hash_set.hashes) },
        });
        if (missingAssets.length === 0) {
            return;
        }
        let totalSize = 0;
        await Promise.all(missingAssets.map(async (asset) => {
            var _a;
            logging_1.ze_log.upload(`Uploading file ${asset.path} to env: ${(0, picocolor_1.whiteBright)(env)}`);
            const start = Date.now();
            const assetWithBuffer = assetsMap[asset.hash];
            const assetSize = ((_a = assetWithBuffer === null || assetWithBuffer === void 0 ? void 0 : assetWithBuffer.buffer) === null || _a === void 0 ? void 0 : _a.length) / 1024;
            await (0, upload_file_1.uploadFile)({
                hash: asset.hash,
                asset: assetWithBuffer,
            }, Object.assign(Object.assign({}, appConfig), { EDGE_URL: envCfg.edgeUrl }));
            const fileUploaded = Date.now() - start;
            totalSize += assetSize;
            logging_1.ze_log.upload(`file ${asset.path} uploaded in ${fileUploaded}ms (${assetSize.toFixed(2)}kb) for env: ${(0, picocolor_1.whiteBright)(env)}`);
        }));
        logging_1.ze_log.upload(`Total size uploaded for env: ${(0, picocolor_1.whiteBright)(env)}: ${totalSize.toFixed(2)}kb`);
    }
}
//# sourceMappingURL=ze-upload-assets.js.map