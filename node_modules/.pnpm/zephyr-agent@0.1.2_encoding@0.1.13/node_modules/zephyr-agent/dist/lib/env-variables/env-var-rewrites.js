"use strict";
// Shared helpers for virtual env module + import map
Object.defineProperty(exports, "__esModule", { value: true });
exports.VIRTUAL_SPECIFIER = void 0;
exports.detectEnvReads = detectEnvReads;
exports.rewriteEnvReadsToVirtualModule = rewriteEnvReadsToVirtualModule;
exports.buildImportMap = buildImportMap;
exports.injectImportMap = injectImportMap;
exports.buildModulePreload = buildModulePreload;
exports.injectBeforeHeadClose = injectBeforeHeadClose;
exports.buildEnvJsonAsset = buildEnvJsonAsset;
exports.generateManifestContent = generateManifestContent;
exports.calculateManifestHash = calculateManifestHash;
exports.collectZEPublicVars = collectZEPublicVars;
exports.VIRTUAL_SPECIFIER = 'env:vars';
// Only match ZE_PUBLIC_* keys
const ZE_REGEX_SIMPLE = /\bprocess\.env\.(ZE_PUBLIC_[A-Z0-9_]+)/g;
const ZE_REGEX_QUOTED = /\bprocess\.env\[["'`](ZE_PUBLIC_[A-Z0-9_]+)["'`]\]/g;
const ZE_REGEX_IMPORT_META_SIMPLE = /\bimport\.meta\.env\.(ZE_PUBLIC_[A-Z0-9_]+)/g;
const ZE_REGEX_IMPORT_META_QUOTED = /\bimport\.meta\.env\[["'`](ZE_PUBLIC_[A-Z0-9_]+)["'`]\]/g;
// Destructuring patterns (declarations): const { ... } = process.env | import.meta.env
const ZE_DESTRUCT_DECL = /(const|let|var)\s*\{([^}]+)\}\s*=\s*(process\.env|import\.meta\.env)/g;
// Destructuring patterns (assignment): ({ ... } = process.env) or { ... } = import.meta.env
const ZE_DESTRUCT_ASSIGN = /\{([^}]+)\}\s*=\s*(process\.env|import\.meta\.env)/g;
function extractDestructuredKeys(raw) {
    // raw is the inside of {...}
    return raw
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean)
        .map((frag) => {
        // Handle patterns:
        // ZE_PUBLIC_FOO
        // ZE_PUBLIC_FOO: ALIAS
        // ZE_PUBLIC_FOO = 'x'
        // ZE_PUBLIC_FOO: ALIAS = 'x'
        const colonIdx = frag.indexOf(':');
        const eqIdx = frag.indexOf('=');
        let base = frag;
        if (colonIdx !== -1)
            base = frag.slice(0, colonIdx).trim();
        else if (eqIdx !== -1)
            base = frag.slice(0, eqIdx).trim();
        return base;
    });
}
function detectEnvReads(source) {
    const names = new Set();
    const regs = [
        ZE_REGEX_SIMPLE,
        ZE_REGEX_QUOTED,
        ZE_REGEX_IMPORT_META_SIMPLE,
        ZE_REGEX_IMPORT_META_QUOTED,
    ];
    for (const r of regs) {
        source.replace(r, (_m, name) => {
            names.add(String(name));
            return _m;
        });
    }
    // Detect destructuring keys and add only ZE_PUBLIC_*
    source.replace(ZE_DESTRUCT_DECL, (_m, _decl, inner) => {
        for (const k of extractDestructuredKeys(String(inner))) {
            if (k.startsWith('ZE_PUBLIC_'))
                names.add(k);
        }
        return _m;
    });
    source.replace(ZE_DESTRUCT_ASSIGN, (_m, inner) => {
        for (const k of extractDestructuredKeys(String(inner))) {
            if (k.startsWith('ZE_PUBLIC_'))
                names.add(k);
        }
        return _m;
    });
    return names;
}
function rewriteEnvReadsToVirtualModule(source, specifier = exports.VIRTUAL_SPECIFIER) {
    const used = detectEnvReads(source);
    if (used.size === 0)
        return { code: source, used };
    // Replace all env var references with __ZE_MANIFEST__.zeVars.VAR_NAME
    let code = source
        .replace(ZE_REGEX_SIMPLE, (_m, name) => `__ZE_MANIFEST__.zeVars.${name}`)
        .replace(ZE_REGEX_QUOTED, (_m, name) => `__ZE_MANIFEST__.zeVars.${name}`)
        .replace(ZE_REGEX_IMPORT_META_SIMPLE, (_m, name) => `__ZE_MANIFEST__.zeVars.${name}`)
        .replace(ZE_REGEX_IMPORT_META_QUOTED, (_m, name) => `__ZE_MANIFEST__.zeVars.${name}`);
    // Replace destructuring RHS env object with __ZE_MANIFEST__.zeVars when ZE_PUBLIC_* keys are present
    code = code.replace(ZE_DESTRUCT_DECL, (m, decl, inner) => {
        const keys = extractDestructuredKeys(String(inner));
        if (!keys.some((k) => k.startsWith('ZE_PUBLIC_')))
            return m;
        return `${decl} {${inner}} = __ZE_MANIFEST__.zeVars`;
    });
    code = code.replace(ZE_DESTRUCT_ASSIGN, (m, inner) => {
        const keys = extractDestructuredKeys(String(inner));
        if (!keys.some((k) => k.startsWith('ZE_PUBLIC_')))
            return m;
        return `{${inner}} = __ZE_MANIFEST__.zeVars`;
    });
    // Ensure an import of the virtual module exists; avoid duplicating if already present
    const escaped = specifier.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const importRe = new RegExp(`from\\s+['"]${escaped}['"];?|require\\(['"]${escaped}['"]\\)`, 'm');
    if (!importRe.test(code)) {
        // Simple default import of the JSON manifest
        code = `import __ZE_MANIFEST__ from '${specifier}' with { type: 'json' };\n` + code;
    }
    return { code, used };
}
function buildImportMap(specifier, url) {
    return JSON.stringify({ imports: { [specifier]: url } }, null, 0);
}
function injectImportMap(html, importMapJson, opts) {
    var _a;
    const scriptTag = `<script type="importmap">${importMapJson}</script>`;
    if (html.includes(scriptTag))
        return html;
    const injectTo = (_a = opts === null || opts === void 0 ? void 0 : opts.injectTo) !== null && _a !== void 0 ? _a : 'head-prepend';
    if (injectTo === 'body')
        return html.replace('</body>', `${scriptTag}</body>`);
    return html.replace('</head>', `${scriptTag}</head>`);
}
function buildModulePreload(url) {
    return `<link rel="modulepreload" href="${url}">`;
}
function injectBeforeHeadClose(html, snippet) {
    if (html.includes(snippet))
        return html;
    return html.replace('</head>', `${snippet}</head>`);
}
function buildEnvJsonAsset(env) {
    const safe = {};
    for (const [k, v] of Object.entries(env)) {
        if (!k.startsWith('ZE_PUBLIC_'))
            continue;
        if (typeof v === 'string')
            safe[k] = v;
    }
    const source = JSON.stringify(safe);
    // djb2
    let h = 5381;
    for (let i = 0; i < source.length; i++)
        h = ((h << 5) + h) ^ source.charCodeAt(i);
    const short = (h >>> 0).toString(36);
    return { fileName: `ze-env.${short}.json`, source };
}
// New functions for zephyr-manifest.json generation
function generateManifestContent(envVars, dependencies = {}) {
    // Filter for ZE_PUBLIC_* variables
    const publicVars = {};
    for (const [key, value] of Object.entries(envVars)) {
        if (key.startsWith('ZE_PUBLIC_')) {
            publicVars[key] = value;
        }
    }
    // Build manifest with unified structure
    const manifest = {
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        dependencies: dependencies,
        zeVars: publicVars,
    };
    return JSON.stringify(manifest, null, 2);
}
function calculateManifestHash(content) {
    // Try to use Node.js crypto module if available
    try {
        const crypto = require('crypto');
        return crypto.createHash('sha256').update(content).digest('hex');
    }
    catch (_a) {
        // Fallback to djb2 hash for environments without crypto
        let h = 5381;
        for (let i = 0; i < content.length; i++) {
            h = ((h << 5) + h) ^ content.charCodeAt(i);
        }
        return (h >>> 0).toString(36);
    }
}
function collectZEPublicVars(env) {
    const vars = {};
    for (const [key, value] of Object.entries(env)) {
        if (key.startsWith('ZE_PUBLIC_') && typeof value === 'string') {
            vars[key] = value;
        }
    }
    return vars;
}
//# sourceMappingURL=env-var-rewrites.js.map