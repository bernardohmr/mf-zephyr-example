"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGitInfo = getGitInfo;
const tslib_1 = require("tslib");
const is_ci_1 = tslib_1.__importDefault(require("is-ci"));
const node_child_process_1 = require("node:child_process");
const node_path_1 = require("node:path");
const node_util_1 = require("node:util");
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const login_1 = require("../auth/login");
const errors_1 = require("../errors");
const http_request_1 = require("../http/http-request");
const logging_1 = require("../logging");
const ze_log_event_1 = require("../logging/ze-log-event");
const secret_token_1 = require("../node-persist/secret-token");
const token_1 = require("../node-persist/token");
const git_provider_utils_1 = require("./git-provider-utils");
const detect_monorepo_1 = require("./detect-monorepo");
const ze_util_read_package_json_1 = require("./ze-util-read-package-json");
const exec = (0, node_util_1.promisify)(node_child_process_1.exec);
/** Generate branch name for non-git contexts */
function generateBranchName(context, userId) {
    const timestamp = new Date().toISOString().replace(/\D/g, '');
    const userSuffix = userId ? `-${userId.slice(0, 8)}` : '';
    return `${context}${userSuffix}-${timestamp}`;
}
/** Loads the git information from the current repository. */
async function getGitInfo() {
    // Always gather fresh git info for build accuracy
    return await gatherGitInfo();
}
/** Internal function that actually gathers git information. */
async function gatherGitInfo() {
    const hasToken = (0, secret_token_1.hasSecretToken)();
    try {
        const { name, email, remoteOrigin, branch, commit, tags, stdout } = await loadGitInfo(hasToken);
        if (!hasToken && (!name || !email)) {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_USERNAME_EMAIL, {
                data: { stdout },
            });
        }
        const app = parseGitUrl(remoteOrigin, stdout);
        const gitInfo = {
            git: { name, email, branch, commit, tags },
            app,
        };
        logging_1.ze_log.git('Loaded: git info', gitInfo);
        return gitInfo;
    }
    catch (error) {
        // In CI environments, fail immediately if git info is not available
        if (is_ci_1.default) {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
                message: 'Git repository information is required in CI environments',
                cause: error,
            });
        }
        // If git repo info is not available, try global git config
        (0, ze_log_event_1.logFn)('warn', 'Git repository not found. Zephyr REQUIRES a git repository with remote origin.');
        (0, ze_log_event_1.logFn)('warn', 'Manual configuration is NOT recommended and WILL cause errors in production.');
        (0, ze_log_event_1.logFn)('warn', '');
        (0, ze_log_event_1.logFn)('warn', 'To properly use Zephyr, you MUST:');
        (0, ze_log_event_1.logFn)('warn', '1. Initialize git: git init');
        (0, ze_log_event_1.logFn)('warn', '2. Add remote: git remote add origin git@github.com:ORG/REPO.git');
        (0, ze_log_event_1.logFn)('warn', '3. Commit your changes: git add . && git commit -m "Initial commit"');
        (0, ze_log_event_1.logFn)('warn', '');
        (0, ze_log_event_1.logFn)('warn', 'Alternative: Use our CLI for automatic setup: npx create-zephyr-apps');
        (0, ze_log_event_1.logFn)('warn', 'ðŸ“ Documentation: https://docs.zephyr-cloud.io');
        logging_1.ze_log.git('Git repository not found, falling back to global git config');
        try {
            const globalGitInfo = await loadGlobalGitInfo();
            return globalGitInfo;
        }
        catch (_a) {
            // If global git config also fails, use defaults
            (0, ze_log_event_1.logFn)('warn', 'Global git config not found, using auto-generated defaults');
            logging_1.ze_log.git('Global git config not found, using auto-generated defaults');
            const fallbackInfo = await getFallbackGitInfo();
            return fallbackInfo;
        }
    }
}
// Static delimiter that's unique enough to avoid conflicts with git output
const GIT_OUTPUT_DELIMITER = '---ZEPHYR-GIT-DELIMITER-8f3a2b1c---';
/** Loads all data in a single command to avoid multiple executions. */
async function loadGitInfo(hasSecretToken) {
    const automated = is_ci_1.default || hasSecretToken;
    const command = [
        // Inside CI environments, the last committer should be the actor
        // and not the actual logged git user which sometimes might just be a bot
        automated ? "git log -1 --pretty=format:'%an'" : 'git config user.name',
        automated ? "git log -1 --pretty=format:'%ae'" : 'git config user.email',
        // TODO: support remote names that are not 'origin'
        'git config --get remote.origin.url',
        'git rev-parse --abbrev-ref HEAD',
        'git rev-parse HEAD',
        'git tag --points-at HEAD',
    ].join(` && echo ${GIT_OUTPUT_DELIMITER} && `);
    try {
        const { stdout } = await exec(command);
        const [name, email, remoteOrigin, branch, commit, tagsOutput] = stdout
            .trim()
            .split(GIT_OUTPUT_DELIMITER)
            .map((x) => x.trim());
        // Parse tags - if multiple tags point to HEAD, they'll be on separate lines
        const tags = tagsOutput ? tagsOutput.split('\n').filter(Boolean) : [];
        return {
            name,
            email,
            remoteOrigin,
            branch,
            commit,
            tags,
            stdout,
        };
    }
    catch (cause) {
        const error = cause;
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
            cause,
            data: { command, delimiter: GIT_OUTPUT_DELIMITER },
            message: (error === null || error === void 0 ? void 0 : error.stderr) || error.message,
        });
    }
}
/**
 * Parses the git url using the `git-url-parse` package.
 *
 * This package differentiates CI providers and handles git info from various platforms
 * like GitHub, GitLab, Bitbucket, and custom git deployments.
 */
function parseGitUrl(remoteOrigin, stdout) {
    if (!remoteOrigin) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_GIT_REMOTE_ORIGIN, {
            data: { stdout },
        });
    }
    try {
        const gitInfo = (0, git_provider_utils_1.getGitProviderInfo)(remoteOrigin);
        logging_1.ze_log.git(`Git provider detected: ${gitInfo.provider}`, {
            provider: gitInfo.provider,
            owner: gitInfo.owner,
            project: gitInfo.project,
            isEnterprise: gitInfo.isEnterprise,
        });
        return {
            org: gitInfo.owner,
            project: gitInfo.project,
        };
    }
    catch (cause) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
            message: stdout,
            cause,
            data: { stdout },
        });
    }
}
/** Try to load git info from global git config */
async function loadGlobalGitInfo() {
    var _a, _b;
    try {
        const [nameResult, emailResult] = await Promise.all([
            exec('git config --global user.name').catch(() => ({ stdout: '' })),
            exec('git config --global user.email').catch(() => ({ stdout: '' })),
        ]);
        const name = (_a = nameResult.stdout) === null || _a === void 0 ? void 0 : _a.trim();
        const email = (_b = emailResult.stdout) === null || _b === void 0 ? void 0 : _b.trim();
        if (!name && !email) {
            (0, ze_log_event_1.logFn)('warn', 'Global git config incomplete: both name and email are missing. Falling back to API user info.');
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
                message: 'Global git config incomplete: both name and email are missing',
            });
        }
        if (!name) {
            (0, ze_log_event_1.logFn)('warn', 'Global git config incomplete: user name is missing. Run: git config --global user.name "Your Name". Falling back to API user info.');
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
                message: 'Global git config incomplete: user name is missing',
            });
        }
        if (!email) {
            (0, ze_log_event_1.logFn)('warn', 'Global git config incomplete: user email is missing. Run: git config --global user.email "your@email.com". Falling back to API user info.');
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
                message: 'Global git config incomplete: user email is missing',
            });
        }
        const { org, project } = await getAppNamingFromPackageJson(name);
        const gitInfo = {
            git: {
                name,
                email,
                branch: generateBranchName('global-git'),
                commit: 'no-git-commit',
                tags: [],
            },
            app: {
                org,
                project,
            },
        };
        logging_1.ze_log.git('Using global git config (no local repository)', gitInfo);
        (0, ze_log_event_1.logFn)('warn', 'Configuration accepted for THIS BUILD ONLY.');
        (0, ze_log_event_1.logFn)('warn', 'This manual configuration will NOT work for production deployments.');
        (0, ze_log_event_1.logFn)('warn', 'Zephyr REQUIRES a proper git repository with remote origin to function correctly.');
        (0, ze_log_event_1.logFn)('warn', 'Please set up git before your next deployment: https://docs.zephyr-cloud.io');
        return gitInfo;
    }
    catch (error) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
            message: 'Failed to load global git config',
            cause: error,
        });
    }
}
/** Get user info from API endpoint instead of JWT decoding */
async function getUserInfoFromAPI() {
    const token = await (0, token_1.getToken)();
    if (!token || !(0, login_1.isTokenStillValid)(token, 60)) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
            message: 'No valid authentication token found. Please login first.',
        });
    }
    const [ok, cause, response] = await (0, http_request_1.makeRequest)({
        path: '/v2/user/me',
        base: (0, zephyr_edge_contract_1.ZE_API_ENDPOINT)(),
        query: {},
    });
    if (!ok) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
            message: 'Failed to get user information from API. Please ensure you are logged in with a valid token.',
            cause,
        });
    }
    const userData = response.value;
    logging_1.ze_log.git('Retrieved user info from API:', {
        name: userData.name,
        email: userData.email,
    });
    return userData;
}
/** Generate fallback git info when git is completely unavailable */
async function getFallbackGitInfo() {
    let userInfo;
    try {
        userInfo = await getUserInfoFromAPI();
    }
    catch (error) {
        logging_1.ze_log.git('Failed to get user info from API:', error);
        throw error;
    }
    const gitName = userInfo.name;
    const gitEmail = userInfo.email;
    if (is_ci_1.default) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
            message: 'Git repository information is required in CI environments. Please ensure your CI workflow includes git repository with proper remote origin.',
        });
    }
    const { org, project } = await getAppNamingFromPackageJson(userInfo.name);
    const gitInfo = {
        git: {
            name: gitName,
            email: gitEmail,
            branch: generateBranchName('no-git', userInfo.id),
            commit: `fallback-deployment-${Date.now()}`,
            tags: [`deployed-by:${userInfo.id}`],
        },
        app: {
            org,
            project,
        },
    };
    logging_1.ze_log.git('Using fallback git info (git not available)', gitInfo);
    (0, ze_log_event_1.logFn)('warn', `Using organization "${org}" from authenticated user.`);
    (0, ze_log_event_1.logFn)('warn', 'Configuration accepted for THIS BUILD ONLY.');
    (0, ze_log_event_1.logFn)('warn', 'This manual configuration will NOT work for production deployments.');
    (0, ze_log_event_1.logFn)('warn', 'Zephyr REQUIRES a proper git repository with remote origin to function correctly.');
    (0, ze_log_event_1.logFn)('warn', 'Please set up git before your next deployment: https://docs.zephyr-cloud.io');
    return gitInfo;
}
/** Sanitize string for use as org/project name */
function sanitizeName(name) {
    return name.replace(/[^a-zA-Z0-9-]/g, '-').toLowerCase();
}
/** Get current directory name as project name */
function getCurrentDirectoryName() {
    const cwd = process.cwd();
    const dirName = cwd.split(node_path_1.sep).pop() || 'untitled-project';
    return sanitizeName(dirName);
}
/**
 * Extract org, project, and app names from package.json structure for non-git
 * environments
 */
async function getAppNamingFromPackageJson(tokenUserName) {
    try {
        const packageJson = await (0, ze_util_read_package_json_1.getPackageJson)(process.cwd());
        const packageName = packageJson.name;
        // Require JWT username for org - no fallback to avoid build loss
        if (!tokenUserName) {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
                message: 'Unable to determine organization: no authenticated user found. Please ensure you are logged in with a valid token.',
            });
        }
        const org = sanitizeName(tokenUserName);
        if (packageName.includes('@')) {
            // Scoped package: @scope/name -> project: scope, app: name
            const [scope, name] = packageName.split('/');
            return {
                org,
                project: scope.replace('@', ''),
                app: name,
            };
        }
        // Check if we're in a monorepo
        const monorepoInfo = await (0, detect_monorepo_1.detectMonorepo)(process.cwd());
        if (monorepoInfo.type !== 'none') {
            // We're in a monorepo
            const rootPackageJson = await (0, detect_monorepo_1.getMonorepoRootPackageJson)(monorepoInfo.root);
            if (rootPackageJson && rootPackageJson['name']) {
                const rootName = rootPackageJson['name'];
                // If root package is scoped, use the scope as project
                if (rootName.includes('@')) {
                    const [scope] = rootName.split('/');
                    return {
                        org,
                        project: scope.replace('@', ''),
                        app: packageName,
                    };
                }
                // Use root package name as project
                return {
                    org,
                    project: sanitizeName(rootName),
                    app: packageName,
                };
            }
            else {
                // No root package.json or no name - use monorepo root directory name
                const rootDirName = monorepoInfo.root.split(node_path_1.sep).pop() || 'monorepo';
                return {
                    org,
                    project: sanitizeName(rootDirName),
                    app: packageName,
                };
            }
        }
        // Not in a monorepo - single package
        return {
            org,
            project: packageName,
            app: packageName,
        };
    }
    catch (_a) {
        // No package.json: use directory name
        const dirName = getCurrentDirectoryName();
        if (!tokenUserName) {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_NO_GIT_INFO, {
                message: 'Unable to determine organization: no authenticated user found and no package.json available. Please ensure you are logged in with a valid token.',
            });
        }
        return {
            org: sanitizeName(tokenUserName),
            project: dirName,
            app: dirName,
        };
    }
}
//# sourceMappingURL=ze-util-get-git-info.js.map