"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectMonorepo = detectMonorepo;
exports.getMonorepoRootPackageJson = getMonorepoRootPackageJson;
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const debug_1 = require("../logging/debug");
const MONOREPO_CONFIG_FILES = [
    { file: 'pnpm-workspace.yaml', type: 'pnpm' },
    { file: 'pnpm-workspace.yml', type: 'pnpm' },
    { file: 'lerna.json', type: 'lerna' },
    { file: 'nx.json', type: 'nx' },
    { file: 'rush.json', type: 'rush' },
];
const MAX_TRAVERSAL_DEPTH = 10;
/**
 * Detects if the current project is part of a monorepo and returns information about it.
 * Traverses up the directory tree looking for monorepo configuration files.
 */
async function detectMonorepo(startPath) {
    var _a, _b;
    let currentDir = (0, node_path_1.resolve)(startPath);
    let depth = 0;
    while (depth < MAX_TRAVERSAL_DEPTH) {
        // Check for specific monorepo config files
        for (const config of MONOREPO_CONFIG_FILES) {
            const configPath = (0, node_path_1.join)(currentDir, config.file);
            if (fileExists(configPath)) {
                debug_1.ze_log.misc(`Found ${config.type} monorepo config at ${configPath}`);
                return {
                    type: config.type,
                    root: currentDir,
                    configFile: configPath,
                };
            }
        }
        // Check for package.json with workspaces
        const packageJsonPath = (0, node_path_1.join)(currentDir, 'package.json');
        if (fileExists(packageJsonPath)) {
            try {
                const content = await (0, promises_1.readFile)(packageJsonPath, 'utf8');
                const packageJson = JSON.parse(content);
                // Check for npm/yarn workspaces
                if (packageJson.workspaces) {
                    debug_1.ze_log.misc(`Found ${((_a = packageJson.packageManager) === null || _a === void 0 ? void 0 : _a.startsWith('yarn')) ? 'yarn' : 'npm'} workspaces at ${packageJsonPath}`);
                    return {
                        type: ((_b = packageJson.packageManager) === null || _b === void 0 ? void 0 : _b.startsWith('yarn')) ? 'yarn' : 'npm',
                        root: currentDir,
                        configFile: packageJsonPath,
                        workspaces: Array.isArray(packageJson.workspaces)
                            ? packageJson.workspaces
                            : packageJson.workspaces.packages || [],
                    };
                }
                // Check for .yarnrc.yml in the same directory (Yarn Berry)
                const yarnrcPath = (0, node_path_1.join)(currentDir, '.yarnrc.yml');
                if (fileExists(yarnrcPath)) {
                    debug_1.ze_log.misc(`Found Yarn Berry workspace at ${currentDir}`);
                    return {
                        type: 'yarn',
                        root: currentDir,
                        configFile: yarnrcPath,
                    };
                }
            }
            catch (error) {
                debug_1.ze_log.misc(`Error reading package.json at ${packageJsonPath}:`, error);
            }
        }
        // Check if we've reached the root
        const parentDir = (0, node_path_1.resolve)(currentDir, '..');
        if (parentDir === currentDir) {
            break;
        }
        currentDir = parentDir;
        depth++;
    }
    debug_1.ze_log.misc('No monorepo configuration found');
    return {
        type: 'none',
        root: startPath,
    };
}
/** Gets the root package.json from a monorepo root directory */
async function getMonorepoRootPackageJson(monorepoRoot) {
    const packageJsonPath = (0, node_path_1.join)(monorepoRoot, 'package.json');
    if (!fileExists(packageJsonPath)) {
        return null;
    }
    try {
        const content = await (0, promises_1.readFile)(packageJsonPath, 'utf8');
        return JSON.parse(content);
    }
    catch (error) {
        debug_1.ze_log.misc(`Error reading root package.json at ${packageJsonPath}:`, error);
        return null;
    }
}
function fileExists(path) {
    try {
        (0, node_fs_1.accessSync)(path, node_fs_1.constants.F_OK);
        return true;
    }
    catch (_a) {
        return false;
    }
}
//# sourceMappingURL=detect-monorepo.js.map