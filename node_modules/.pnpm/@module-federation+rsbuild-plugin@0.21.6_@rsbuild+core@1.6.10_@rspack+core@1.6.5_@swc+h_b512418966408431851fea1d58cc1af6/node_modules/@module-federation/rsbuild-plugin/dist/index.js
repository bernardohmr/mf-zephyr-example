"use strict";
const __rslib_import_meta_url__ = /*#__PURE__*/ function() {
    return 'undefined' == typeof document ? new (require('url'.replace('', ''))).URL('file:' + __filename).href : document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href;
}();
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    pluginModuleFederation: ()=>pluginModuleFederation,
    RSBUILD_PLUGIN_MODULE_FEDERATION_NAME: ()=>RSBUILD_PLUGIN_MODULE_FEDERATION_NAME,
    PLUGIN_NAME: ()=>rspack_namespaceObject.PLUGIN_NAME,
    SSR_DIR: ()=>SSR_DIR,
    isMFFormat: ()=>isMFFormat,
    createModuleFederationConfig: ()=>sdk_namespaceObject.createModuleFederationConfig
});
const enhanced_namespaceObject = require("@module-federation/enhanced");
const rspack_namespaceObject = require("@module-federation/enhanced/rspack");
const sdk_namespaceObject = require("@module-federation/sdk");
var package_namespaceObject = JSON.parse('{"UU":"@module-federation/rsbuild-plugin"}');
const logger = (0, sdk_namespaceObject.createLogger)('[ Module Federation Rsbuild Plugin ]');
const src_logger = logger;
const external_util_namespaceObject = require("util");
var external_util_default = /*#__PURE__*/ __webpack_require__.n(external_util_namespaceObject);
const SPLIT_CHUNK_MAP = {
    REACT: 'react',
    ROUTER: 'router',
    LODASH: 'lib-lodash',
    ANTD: 'lib-antd',
    ARCO: 'lib-arco',
    SEMI: 'lib-semi',
    AXIOS: 'lib-axios'
};
const SHARED_SPLIT_CHUNK_MAP = {
    react: SPLIT_CHUNK_MAP.REACT,
    'react-dom': SPLIT_CHUNK_MAP.REACT,
    'react-router': SPLIT_CHUNK_MAP.ROUTER,
    'react-router-dom': SPLIT_CHUNK_MAP.ROUTER,
    '@remix-run/router': SPLIT_CHUNK_MAP.ROUTER,
    lodash: SPLIT_CHUNK_MAP.LODASH,
    'lodash-es': SPLIT_CHUNK_MAP.LODASH,
    antd: SPLIT_CHUNK_MAP.ANTD,
    '@arco-design/web-react': SPLIT_CHUNK_MAP.ARCO,
    '@douyinfe/semi-ui': SPLIT_CHUNK_MAP.SEMI,
    axios: SPLIT_CHUNK_MAP.AXIOS
};
function autoDeleteSplitChunkCacheGroups(mfConfig, splitChunks) {
    if (!mfConfig.shared) return;
    if (!splitChunks || !(null == splitChunks ? void 0 : splitChunks.cacheGroups)) return;
    const arrayShared = Array.isArray(mfConfig.shared) ? mfConfig.shared : Object.keys(mfConfig.shared);
    for (const shared of arrayShared){
        const splitChunkKey = SHARED_SPLIT_CHUNK_MAP[shared];
        if (splitChunkKey) {
            if (splitChunks.cacheGroups[splitChunkKey]) delete splitChunks.cacheGroups[splitChunkKey];
        }
    }
    return splitChunks;
}
const external_fs_extra_namespaceObject = require("fs-extra");
var external_fs_extra_default = /*#__PURE__*/ __webpack_require__.n(external_fs_extra_namespaceObject);
const external_path_namespaceObject = require("path");
var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
const DATA_FETCH_CLIENT_SUFFIX = '.client';
const CALL_NAME_MAP = {
    RSPRESS: 'rspress',
    RSLIB: 'rslib'
};
const addDataFetchExpose = (exposes, key, filepath, suffix = '')=>{
    if (!external_fs_extra_default().existsSync(filepath)) return false;
    const dataFetchKey = '.' === key ? `./data${suffix}` : `${key}.data${suffix}`;
    if (exposes[dataFetchKey] && exposes[dataFetchKey] !== filepath) throw new Error(`data fetch key ${dataFetchKey} already exists, please modify this expose key, do not end with 'data' or '${DATA_FETCH_CLIENT_SUFFIX}'`);
    exposes[dataFetchKey] = filepath;
    return dataFetchKey;
};
const addExcludeDtsSuffix = (filepath)=>`${filepath}?exclude-mf-dts=true`;
function addDataFetchExposes(exposes, isServer) {
    if ('object' != typeof exposes || Array.isArray(exposes)) return;
    if (0 === Object.keys(exposes).length) return;
    const tempDataFetch = external_path_default().resolve(process.cwd(), `node_modules/${sdk_namespaceObject.TEMP_DIR}`);
    const content = "export const fetchData=()=>{throw new Error('should not be called')};";
    external_fs_extra_default().ensureDirSync(tempDataFetch);
    Object.keys(exposes).forEach((key, index)=>{
        const expose = exposes[key];
        if ('string' != typeof expose) return;
        const absPath = external_path_default().resolve(process.cwd(), expose);
        const dataFetchPath = `${absPath.replace(external_path_default().extname(absPath), '')}.data.ts`;
        const dataFetchClientPath = `${absPath.replace(external_path_default().extname(absPath), '')}.data.client.ts`;
        const tempFile = external_path_default().join(tempDataFetch, `data-fetch-fallback${index}.ts`);
        external_fs_extra_default().writeFileSync(tempFile, content);
        const dateFetchClientKey = addDataFetchExpose(exposes, key, dataFetchClientPath, DATA_FETCH_CLIENT_SUFFIX);
        if (!isServer && dateFetchClientKey) {
            exposes[dateFetchClientKey.replace(DATA_FETCH_CLIENT_SUFFIX, '')] = addExcludeDtsSuffix(tempFile);
            return;
        }
        const dataFetchKey = addDataFetchExpose(exposes, key, dataFetchPath);
        if (dataFetchKey && external_fs_extra_default().existsSync(dataFetchClientPath)) exposes[`${dataFetchKey}${DATA_FETCH_CLIENT_SUFFIX}`] = addExcludeDtsSuffix(tempFile);
    });
}
function mergeStats(browserStats, nodeStats) {
    const ssrRemoteEntry = nodeStats.metaData.remoteEntry;
    browserStats.metaData.ssrRemoteEntry = ssrRemoteEntry;
    if ('publicPath' in browserStats.metaData) browserStats.metaData.ssrPublicPath = nodeStats.metaData.publicPath;
    return browserStats;
}
function mergeManifest(browserManifest, nodeManifest) {
    const ssrRemoteEntry = nodeManifest.metaData.remoteEntry;
    browserManifest.metaData.ssrRemoteEntry = ssrRemoteEntry;
    if ('publicPath' in browserManifest.metaData) browserManifest.metaData.ssrPublicPath = nodeManifest.metaData.publicPath;
    return browserManifest;
}
function mergeStatsAndManifest(nodeAssets, browserAssets) {
    const { stats: browserStats, manifest: browserManifest } = browserAssets;
    const { stats: nodeStats, manifest: nodeManifest } = nodeAssets;
    if (!browserStats || !nodeStats || !browserManifest || !nodeManifest) throw new Error('Failed to read stats or manifest assets for merge');
    const mergedStats = mergeStats(browserStats.data, nodeStats.data);
    const mergedManifest = mergeManifest(browserManifest.data, nodeManifest.data);
    return {
        mergedStats: mergedStats,
        mergedStatsFilePath: browserStats.filename,
        mergedManifest: mergedManifest,
        mergedManifestFilePath: browserManifest.filename
    };
}
function updateStatsAndManifest(nodeAssets, browserAssets, outputDir) {
    const { mergedStats, mergedStatsFilePath, mergedManifest, mergedManifestFilePath } = mergeStatsAndManifest(nodeAssets, browserAssets);
    external_fs_extra_default().writeFileSync(external_path_default().resolve(outputDir, mergedStatsFilePath), JSON.stringify(mergedStats, null, 2));
    external_fs_extra_default().writeFileSync(external_path_default().resolve(outputDir, mergedManifestFilePath), JSON.stringify(mergedManifest, null, 2));
}
const external_node_module_namespaceObject = require("node:module");
const ssr_require = (0, external_node_module_namespaceObject.createRequire)(__rslib_import_meta_url__);
const resolve = ssr_require.resolve;
const SSR_DIR = 'ssr';
const SSR_ENV_NAME = 'mf-ssr';
function setSSREnv() {
    process.env['MF_SSR_PRJ'] = 'true';
}
const isDev = ()=>'development' === process.env['NODE_ENV'];
function patchSSRRspackConfig(config, mfConfig, ssrDir, callerName, resetEntry = true, modifyPublicPath = true) {
    var _config_output;
    config.output ||= {};
    if (modifyPublicPath) {
        var _config_output1;
        if ('string' != typeof (null == (_config_output1 = config.output) ? void 0 : _config_output1.publicPath)) throw new Error('publicPath must be string!');
        const publicPath = config.output.publicPath;
        if ('auto' === publicPath) throw new Error('publicPath can not be "auto"!');
        const publicPathWithSSRDir = `${publicPath}${ssrDir}/`;
        config.output.publicPath = publicPathWithSSRDir;
    }
    if (callerName === CALL_NAME_MAP.RSPRESS && resetEntry) config.entry = 'data:application/node;base64,';
    config.target = 'async-node';
    const UniverseEntryChunkTrackerPlugin = ssr_require('@module-federation/node/universe-entry-chunk-tracker-plugin').default;
    config.plugins ||= [];
    isDev() && config.plugins.push(new UniverseEntryChunkTrackerPlugin());
    const uniqueName = mfConfig.name || (null == (_config_output = config.output) ? void 0 : _config_output.uniqueName);
    const chunkFileName = config.output.chunkFilename;
    if ('string' == typeof chunkFileName && uniqueName && !chunkFileName.includes(uniqueName)) {
        const suffix = `${(0, sdk_namespaceObject.encodeName)(uniqueName)}-[contenthash].js`;
        config.output.chunkFilename = chunkFileName.replace('.js', suffix);
    }
    return config;
}
function createSSRREnvConfig(envConfig, mfConfig, ssrDir, rsbuildConfig, callerName) {
    var _ssrEnvConfig_output, _ssrEnvConfig_output_distPath, _ssrEnvConfig_output1, _rsbuildConfig_output_distPath, _rsbuildConfig_output;
    const ssrEnvConfig = {
        ...envConfig,
        tools: {
            rspack: (config, { environment })=>{
                if (environment.name !== SSR_ENV_NAME) return;
                patchSSRRspackConfig(config, mfConfig, ssrDir, callerName);
            }
        }
    };
    ssrEnvConfig.output = {
        ...ssrEnvConfig.output,
        target: 'node',
        distPath: {
            ...null == (_ssrEnvConfig_output = ssrEnvConfig.output) ? void 0 : _ssrEnvConfig_output.distPath,
            root: external_path_default().join((null == (_ssrEnvConfig_output1 = ssrEnvConfig.output) ? void 0 : null == (_ssrEnvConfig_output_distPath = _ssrEnvConfig_output1.distPath) ? void 0 : _ssrEnvConfig_output_distPath.root) || (null == (_rsbuildConfig_output = rsbuildConfig.output) ? void 0 : null == (_rsbuildConfig_output_distPath = _rsbuildConfig_output.distPath) ? void 0 : _rsbuildConfig_output_distPath.root) || '', ssrDir)
        },
        emitAssets: true
    };
    return ssrEnvConfig;
}
function createSSRMFConfig(mfConfig) {
    var _mfConfig_library;
    const ssrMFConfig = {
        ...mfConfig,
        exposes: {
            ...mfConfig.exposes
        },
        library: {
            ...mfConfig.library,
            name: mfConfig.name,
            type: (null == (_mfConfig_library = mfConfig.library) ? void 0 : _mfConfig_library.type) ?? 'commonjs-module'
        },
        dts: false,
        dev: false,
        runtimePlugins: [
            ...mfConfig.runtimePlugins || []
        ]
    };
    ssrMFConfig.runtimePlugins.push(resolve('@module-federation/node/runtimePlugin'));
    if (isDev()) ssrMFConfig.runtimePlugins.push(resolve('@module-federation/node/record-dynamic-remote-entry-hash-plugin'));
    return ssrMFConfig;
}
function isRegExp(target) {
    return external_util_default().types.isRegExp(target);
}
const RSBUILD_PLUGIN_MODULE_FEDERATION_NAME = 'rsbuild:module-federation-enhanced';
const RSBUILD_PLUGIN_NAME = '@module-federation/rsbuild-plugin';
const LIB_FORMAT = [
    'umd',
    'modern-module'
];
const DEFAULT_MF_ENVIRONMENT_NAME = 'mf';
function isStoryBook(rsbuildConfig) {
    var _rsbuildConfig_plugins;
    if (null == (_rsbuildConfig_plugins = rsbuildConfig.plugins) ? void 0 : _rsbuildConfig_plugins.find((p)=>p && 'name' in p && 'module-federation-storybook-plugin' === p.name)) return true;
    return false;
}
function isMFFormat(bundlerConfig) {
    var _bundlerConfig_output;
    const library = null == (_bundlerConfig_output = bundlerConfig.output) ? void 0 : _bundlerConfig_output.library;
    if (bundlerConfig.name === SSR_ENV_NAME) return true;
    return !('object' == typeof library && !Array.isArray(library) && 'type' in library && (LIB_FORMAT.includes(library.type) || /commonjs/.test(library.type)));
}
const isSSRConfig = (bundlerConfigName)=>Boolean(bundlerConfigName === SSR_ENV_NAME);
const isRspressSSGConfig = (bundlerConfigName)=>"node" === bundlerConfigName;
const pluginModuleFederation = (moduleFederationOptions, rsbuildOptions)=>({
        name: RSBUILD_PLUGIN_MODULE_FEDERATION_NAME,
        setup: (api)=>{
            const { ssr, ssrDir = SSR_DIR, environment = DEFAULT_MF_ENVIRONMENT_NAME } = rsbuildOptions || {};
            const { callerName } = api.context;
            const originalRsbuildConfig = api.getRsbuildConfig();
            if (!callerName) throw new Error('`callerName` is undefined. Please ensure the @rsbuild/core version is higher than 1.3.21 .');
            const isRslib = callerName === CALL_NAME_MAP.RSLIB;
            const isRspress = callerName === CALL_NAME_MAP.RSPRESS;
            const isSSR = Boolean(ssr);
            if (isSSR && !isStoryBook(originalRsbuildConfig)) {
                var _rsbuildConfig_environments;
                if (!isRslib && !isRspress) throw new Error("'ssr' option is only supported in rslib.");
                const rsbuildConfig = api.getRsbuildConfig();
                if (!(null == (_rsbuildConfig_environments = rsbuildConfig.environments) ? void 0 : _rsbuildConfig_environments[environment]) || Object.keys(rsbuildConfig.environments).some((key)=>key.startsWith(environment) && key !== environment)) throw new Error(`Please set ${RSBUILD_PLUGIN_NAME} as global plugin in rslib.config.ts if you set 'ssr:true' .`);
                setSSREnv();
            }
            const sharedOptions = (0, enhanced_namespaceObject.parseOptions)(moduleFederationOptions.shared || [], (item, key)=>{
                if ('string' != typeof item) throw new Error('Unexpected array in shared');
                const config = item !== key && (0, sdk_namespaceObject.isRequiredVersion)(item) ? {
                    import: key,
                    requiredVersion: item
                } : {
                    import: item
                };
                return config;
            }, (item, key)=>item);
            const shared = sharedOptions.map((shared)=>shared[0].endsWith('/') ? shared[0].slice(0, -1) : shared[0]);
            api.modifyRsbuildConfig((config)=>{
                if (isStoryBook(config)) return;
                if (moduleFederationOptions.exposes) {
                    var _userConfig_server, _config_server, _config_dev_client, _originalConfig_dev, _config_server1;
                    config.dev ||= {};
                    config.server ||= {};
                    const userConfig = api.getRsbuildConfig('original');
                    config.server.headers ||= {};
                    if (!config.server.headers['Access-Control-Allow-Origin'] && !('object' == typeof (null == (_userConfig_server = userConfig.server) ? void 0 : _userConfig_server.cors) && userConfig.server.cors.origin)) {
                        const corsWarnMsgs = [
                            'Detect that CORS options are not set, mf Rsbuild plugin will add default cors header: server.headers["Access-Control-Allow-Headers"] = "*". It is recommended to specify an allowlist of trusted origins in "server.cors" instead.',
                            'View https://module-federation.io/guide/troubleshooting/other.html#cors-warn for more details.'
                        ];
                        isRslib || isRspress || src_logger.warn(corsWarnMsgs.join('\n'));
                        config.server.headers['Access-Control-Allow-Origin'] = '*';
                    }
                    if ((null == (_config_server = config.server) ? void 0 : _config_server.port) && !(null == (_config_dev_client = config.dev.client) ? void 0 : _config_dev_client.port)) {
                        config.dev.client ||= {};
                        config.dev.client.port = config.server.port;
                    }
                    const originalConfig = api.getRsbuildConfig('original');
                    if ((null == (_originalConfig_dev = originalConfig.dev) ? void 0 : _originalConfig_dev.assetPrefix) === void 0 && config.dev.assetPrefix === (null == (_config_server1 = config.server) ? void 0 : _config_server1.base)) config.dev.assetPrefix = true;
                }
                if (isSSR) {
                    var _config_environments, _config_environments1;
                    if (null == (_config_environments = config.environments) ? void 0 : _config_environments[SSR_ENV_NAME]) throw new Error(`'${SSR_ENV_NAME}' environment is already defined. Please use another name.`);
                    config.environments[SSR_ENV_NAME] = createSSRREnvConfig(null == (_config_environments1 = config.environments) ? void 0 : _config_environments1[environment], moduleFederationOptions, ssrDir, config, callerName);
                }
            });
            api.modifyEnvironmentConfig((config)=>{
                config.source.include = [
                    ...config.source.include || [],
                    /@module-federation[\\/]/
                ];
                return config;
            });
            const generateMergedStatsAndManifestOptions = {
                options: {
                    nodePlugin: void 0,
                    browserPlugin: void 0,
                    rspressSSGPlugin: void 0,
                    distOutputDir: void 0,
                    browserEnvironmentName: void 0,
                    nodeEnvironmentName: void 0
                },
                assetResources: {},
                isSSRConfig,
                isRspressSSGConfig
            };
            api.expose(RSBUILD_PLUGIN_MODULE_FEDERATION_NAME, generateMergedStatsAndManifestOptions);
            const defaultBrowserEnvironmentName = environment;
            const assetFileNames = (0, sdk_namespaceObject.getManifestFileName)(moduleFederationOptions.manifest);
            if (false !== moduleFederationOptions.manifest) api.processAssets({
                stage: 'report'
            }, ({ assets, environment: envContext })=>{
                const expectedBrowserEnv = generateMergedStatsAndManifestOptions.options.browserEnvironmentName ?? defaultBrowserEnvironmentName;
                const expectedNodeEnv = generateMergedStatsAndManifestOptions.options.nodeEnvironmentName ?? SSR_ENV_NAME;
                const envName = envContext.name;
                if (envName !== expectedBrowserEnv && envName !== expectedNodeEnv) return;
                const assetResources = generateMergedStatsAndManifestOptions.assetResources;
                const targetResources = assetResources[envName] || (assetResources[envName] = {});
                const statsAsset = assets[assetFileNames.statsFileName];
                if (statsAsset) try {
                    const raw = statsAsset.source();
                    const content = 'string' == typeof raw ? raw : raw.toString();
                    targetResources.stats = {
                        data: JSON.parse(content),
                        filename: assetFileNames.statsFileName
                    };
                } catch (err) {
                    const message = err instanceof Error ? err.message : String(err);
                    src_logger.error(`Failed to parse stats asset "${assetFileNames.statsFileName}" for environment "${envName}": ${message}`);
                }
                const manifestAsset = assets[assetFileNames.manifestFileName];
                if (manifestAsset) try {
                    const raw = manifestAsset.source();
                    const content = 'string' == typeof raw ? raw : raw.toString();
                    targetResources.manifest = {
                        data: JSON.parse(content),
                        filename: assetFileNames.manifestFileName
                    };
                } catch (err) {
                    const message = err instanceof Error ? err.message : String(err);
                    src_logger.error(`Failed to parse manifest asset "${assetFileNames.manifestFileName}" for environment "${envName}": ${message}`);
                }
            });
            api.onBeforeCreateCompiler(({ bundlerConfigs })=>{
                if (!bundlerConfigs) throw new Error('Can not get bundlerConfigs!');
                bundlerConfigs.forEach((bundlerConfig)=>{
                    if (!isMFFormat(bundlerConfig) && !isRspress) return;
                    if (isStoryBook(originalRsbuildConfig)) bundlerConfig.output.uniqueName = `${moduleFederationOptions.name}-storybook-host`;
                    else {
                        var _bundlerConfig_optimization, _bundlerConfig_optimization1, _bundlerConfig_output, _bundlerConfig_output1;
                        autoDeleteSplitChunkCacheGroups(moduleFederationOptions, null == bundlerConfig ? void 0 : null == (_bundlerConfig_optimization = bundlerConfig.optimization) ? void 0 : _bundlerConfig_optimization.splitChunks);
                        addDataFetchExposes(moduleFederationOptions.exposes, isSSRConfig(bundlerConfig.name));
                        null == (_bundlerConfig_optimization1 = bundlerConfig.optimization) || delete _bundlerConfig_optimization1.runtimeChunk;
                        const externals = bundlerConfig.externals;
                        if (Array.isArray(externals)) {
                            const sharedModules = new Set();
                            bundlerConfig.externals = externals.filter((ext)=>{
                                let sharedModule;
                                if (isRegExp(ext)) {
                                    const match = shared.some((dep)=>{
                                        if (ext.test(dep) || ext.test(package_namespaceObject.UU)) {
                                            sharedModule = dep;
                                            return true;
                                        }
                                        return false;
                                    });
                                    match && sharedModule && sharedModules.add(sharedModule);
                                    return !match;
                                }
                                if ('string' == typeof ext) {
                                    if (ext === package_namespaceObject.UU) return false;
                                    const match = shared.some((dep)=>{
                                        if (dep === ext) sharedModule = dep;
                                        return dep === ext;
                                    });
                                    if (match) {
                                        sharedModule && sharedModules.add(sharedModule);
                                        return false;
                                    }
                                }
                                return true;
                            });
                            if (sharedModules.size > 0) for (const sharedModule of sharedModules)src_logger.log(`${sharedModule} is removed from externals because it is a shared module.`);
                        }
                        if (!(null == (_bundlerConfig_output = bundlerConfig.output) ? void 0 : _bundlerConfig_output.chunkLoadingGlobal) && !isSSRConfig(bundlerConfig.name) && !isRspressSSGConfig(bundlerConfig.name)) {
                            bundlerConfig.output.chunkLoading = 'jsonp';
                            bundlerConfig.output.chunkLoadingGlobal = `chunk_${moduleFederationOptions.name}`;
                        }
                        if (!(null == (_bundlerConfig_output1 = bundlerConfig.output) ? void 0 : _bundlerConfig_output1.uniqueName)) bundlerConfig.output.uniqueName = moduleFederationOptions.name;
                        if (!bundlerConfig.plugins.find((p)=>p && p.name === rspack_namespaceObject.PLUGIN_NAME)) {
                            var _bundlerConfig_output2;
                            if (isSSRConfig(bundlerConfig.name)) {
                                generateMergedStatsAndManifestOptions.options.nodePlugin = new rspack_namespaceObject.ModuleFederationPlugin(createSSRMFConfig(moduleFederationOptions));
                                generateMergedStatsAndManifestOptions.options.nodeEnvironmentName = bundlerConfig.name || SSR_ENV_NAME;
                                bundlerConfig.plugins.push(generateMergedStatsAndManifestOptions.options.nodePlugin);
                                return;
                            }
                            if (isRspressSSGConfig(bundlerConfig.name)) {
                                const mfConfig = {
                                    ...createSSRMFConfig(moduleFederationOptions),
                                    exposes: {},
                                    manifest: false,
                                    library: void 0
                                };
                                patchSSRRspackConfig(bundlerConfig, mfConfig, "ssr", callerName, false, false);
                                bundlerConfig.output ||= {};
                                bundlerConfig.output.publicPath = '/';
                                bundlerConfig.output.asyncChunks = void 0;
                                generateMergedStatsAndManifestOptions.options.rspressSSGPlugin = new rspack_namespaceObject.ModuleFederationPlugin(mfConfig);
                                bundlerConfig.plugins.push(generateMergedStatsAndManifestOptions.options.rspressSSGPlugin);
                                return;
                            }
                            generateMergedStatsAndManifestOptions.options.browserPlugin = new rspack_namespaceObject.ModuleFederationPlugin(moduleFederationOptions);
                            generateMergedStatsAndManifestOptions.options.distOutputDir = (null == (_bundlerConfig_output2 = bundlerConfig.output) ? void 0 : _bundlerConfig_output2.path) || '';
                            generateMergedStatsAndManifestOptions.options.browserEnvironmentName = bundlerConfig.name || defaultBrowserEnvironmentName;
                            bundlerConfig.plugins.push(generateMergedStatsAndManifestOptions.options.browserPlugin);
                        }
                    }
                });
            });
            const generateMergedStatsAndManifest = ()=>{
                const { distOutputDir, browserEnvironmentName, nodeEnvironmentName } = generateMergedStatsAndManifestOptions.options;
                if (!distOutputDir || !browserEnvironmentName || !nodeEnvironmentName) return;
                const assetResources = generateMergedStatsAndManifestOptions.assetResources;
                const browserAssets = assetResources[browserEnvironmentName];
                const nodeAssets = assetResources[nodeEnvironmentName];
                if (!browserAssets || !nodeAssets) return;
                try {
                    updateStatsAndManifest(nodeAssets, browserAssets, distOutputDir);
                } catch (err) {
                    src_logger.error(err);
                }
            };
            api.onDevCompileDone(()=>{
                generateMergedStatsAndManifest();
            });
            api.onAfterBuild(()=>{
                generateMergedStatsAndManifest();
            });
        }
    });
exports.PLUGIN_NAME = __webpack_exports__.PLUGIN_NAME;
exports.RSBUILD_PLUGIN_MODULE_FEDERATION_NAME = __webpack_exports__.RSBUILD_PLUGIN_MODULE_FEDERATION_NAME;
exports.SSR_DIR = __webpack_exports__.SSR_DIR;
exports.createModuleFederationConfig = __webpack_exports__.createModuleFederationConfig;
exports.isMFFormat = __webpack_exports__.isMFFormat;
exports.pluginModuleFederation = __webpack_exports__.pluginModuleFederation;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "PLUGIN_NAME",
    "RSBUILD_PLUGIN_MODULE_FEDERATION_NAME",
    "SSR_DIR",
    "createModuleFederationConfig",
    "isMFFormat",
    "pluginModuleFederation"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
