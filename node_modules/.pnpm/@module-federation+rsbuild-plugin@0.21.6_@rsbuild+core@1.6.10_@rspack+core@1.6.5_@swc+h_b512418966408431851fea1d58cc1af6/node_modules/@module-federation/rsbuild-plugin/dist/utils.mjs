import util from "util";
import fs_extra from "fs-extra";
import path from "path";
import { TEMP_DIR, encodeName } from "@module-federation/sdk";
import { createRequire } from "node:module";
const DATA_FETCH_CLIENT_SUFFIX = '.client';
const CALL_NAME_MAP = {
    RSPRESS: 'rspress',
    RSLIB: 'rslib'
};
const SPLIT_CHUNK_MAP = {
    REACT: 'react',
    ROUTER: 'router',
    LODASH: 'lib-lodash',
    ANTD: 'lib-antd',
    ARCO: 'lib-arco',
    SEMI: 'lib-semi',
    AXIOS: 'lib-axios'
};
const SHARED_SPLIT_CHUNK_MAP = {
    react: SPLIT_CHUNK_MAP.REACT,
    'react-dom': SPLIT_CHUNK_MAP.REACT,
    'react-router': SPLIT_CHUNK_MAP.ROUTER,
    'react-router-dom': SPLIT_CHUNK_MAP.ROUTER,
    '@remix-run/router': SPLIT_CHUNK_MAP.ROUTER,
    lodash: SPLIT_CHUNK_MAP.LODASH,
    'lodash-es': SPLIT_CHUNK_MAP.LODASH,
    antd: SPLIT_CHUNK_MAP.ANTD,
    '@arco-design/web-react': SPLIT_CHUNK_MAP.ARCO,
    '@douyinfe/semi-ui': SPLIT_CHUNK_MAP.SEMI,
    axios: SPLIT_CHUNK_MAP.AXIOS
};
function autoDeleteSplitChunkCacheGroups(mfConfig, splitChunks) {
    if (!mfConfig.shared) return;
    if (!splitChunks || !(null == splitChunks ? void 0 : splitChunks.cacheGroups)) return;
    const arrayShared = Array.isArray(mfConfig.shared) ? mfConfig.shared : Object.keys(mfConfig.shared);
    for (const shared of arrayShared){
        const splitChunkKey = SHARED_SPLIT_CHUNK_MAP[shared];
        if (splitChunkKey) {
            if (splitChunks.cacheGroups[splitChunkKey]) delete splitChunks.cacheGroups[splitChunkKey];
        }
    }
    return splitChunks;
}
const addDataFetchExpose = (exposes, key, filepath, suffix = '')=>{
    if (!fs_extra.existsSync(filepath)) return false;
    const dataFetchKey = '.' === key ? `./data${suffix}` : `${key}.data${suffix}`;
    if (exposes[dataFetchKey] && exposes[dataFetchKey] !== filepath) throw new Error(`data fetch key ${dataFetchKey} already exists, please modify this expose key, do not end with 'data' or '${DATA_FETCH_CLIENT_SUFFIX}'`);
    exposes[dataFetchKey] = filepath;
    return dataFetchKey;
};
const addExcludeDtsSuffix = (filepath)=>`${filepath}?exclude-mf-dts=true`;
function addDataFetchExposes(exposes, isServer) {
    if ('object' != typeof exposes || Array.isArray(exposes)) return;
    if (0 === Object.keys(exposes).length) return;
    const tempDataFetch = path.resolve(process.cwd(), `node_modules/${TEMP_DIR}`);
    const content = "export const fetchData=()=>{throw new Error('should not be called')};";
    fs_extra.ensureDirSync(tempDataFetch);
    Object.keys(exposes).forEach((key, index)=>{
        const expose = exposes[key];
        if ('string' != typeof expose) return;
        const absPath = path.resolve(process.cwd(), expose);
        const dataFetchPath = `${absPath.replace(path.extname(absPath), '')}.data.ts`;
        const dataFetchClientPath = `${absPath.replace(path.extname(absPath), '')}.data.client.ts`;
        const tempFile = path.join(tempDataFetch, `data-fetch-fallback${index}.ts`);
        fs_extra.writeFileSync(tempFile, content);
        const dateFetchClientKey = addDataFetchExpose(exposes, key, dataFetchClientPath, DATA_FETCH_CLIENT_SUFFIX);
        if (!isServer && dateFetchClientKey) {
            exposes[dateFetchClientKey.replace(DATA_FETCH_CLIENT_SUFFIX, '')] = addExcludeDtsSuffix(tempFile);
            return;
        }
        const dataFetchKey = addDataFetchExpose(exposes, key, dataFetchPath);
        if (dataFetchKey && fs_extra.existsSync(dataFetchClientPath)) exposes[`${dataFetchKey}${DATA_FETCH_CLIENT_SUFFIX}`] = addExcludeDtsSuffix(tempFile);
    });
}
function mergeStats(browserStats, nodeStats) {
    const ssrRemoteEntry = nodeStats.metaData.remoteEntry;
    browserStats.metaData.ssrRemoteEntry = ssrRemoteEntry;
    if ('publicPath' in browserStats.metaData) browserStats.metaData.ssrPublicPath = nodeStats.metaData.publicPath;
    return browserStats;
}
function mergeManifest(browserManifest, nodeManifest) {
    const ssrRemoteEntry = nodeManifest.metaData.remoteEntry;
    browserManifest.metaData.ssrRemoteEntry = ssrRemoteEntry;
    if ('publicPath' in browserManifest.metaData) browserManifest.metaData.ssrPublicPath = nodeManifest.metaData.publicPath;
    return browserManifest;
}
function mergeStatsAndManifest(nodeAssets, browserAssets) {
    const { stats: browserStats, manifest: browserManifest } = browserAssets;
    const { stats: nodeStats, manifest: nodeManifest } = nodeAssets;
    if (!browserStats || !nodeStats || !browserManifest || !nodeManifest) throw new Error('Failed to read stats or manifest assets for merge');
    const mergedStats = mergeStats(browserStats.data, nodeStats.data);
    const mergedManifest = mergeManifest(browserManifest.data, nodeManifest.data);
    return {
        mergedStats: mergedStats,
        mergedStatsFilePath: browserStats.filename,
        mergedManifest: mergedManifest,
        mergedManifestFilePath: browserManifest.filename
    };
}
function updateStatsAndManifest(nodeAssets, browserAssets, outputDir) {
    const { mergedStats, mergedStatsFilePath, mergedManifest, mergedManifestFilePath } = mergeStatsAndManifest(nodeAssets, browserAssets);
    fs_extra.writeFileSync(path.resolve(outputDir, mergedStatsFilePath), JSON.stringify(mergedStats, null, 2));
    fs_extra.writeFileSync(path.resolve(outputDir, mergedManifestFilePath), JSON.stringify(mergedManifest, null, 2));
}
const ssr_require = createRequire(import.meta.url);
const resolve = ssr_require.resolve;
const SSR_DIR = 'ssr';
const SSR_ENV_NAME = 'mf-ssr';
function setSSREnv() {
    process.env['MF_SSR_PRJ'] = 'true';
}
const isDev = ()=>'development' === process.env['NODE_ENV'];
function patchSSRRspackConfig(config, mfConfig, ssrDir, callerName, resetEntry = true, modifyPublicPath = true) {
    var _config_output;
    config.output ||= {};
    if (modifyPublicPath) {
        var _config_output1;
        if ('string' != typeof (null == (_config_output1 = config.output) ? void 0 : _config_output1.publicPath)) throw new Error('publicPath must be string!');
        const publicPath = config.output.publicPath;
        if ('auto' === publicPath) throw new Error('publicPath can not be "auto"!');
        const publicPathWithSSRDir = `${publicPath}${ssrDir}/`;
        config.output.publicPath = publicPathWithSSRDir;
    }
    if (callerName === CALL_NAME_MAP.RSPRESS && resetEntry) config.entry = 'data:application/node;base64,';
    config.target = 'async-node';
    const UniverseEntryChunkTrackerPlugin = ssr_require('@module-federation/node/universe-entry-chunk-tracker-plugin').default;
    config.plugins ||= [];
    isDev() && config.plugins.push(new UniverseEntryChunkTrackerPlugin());
    const uniqueName = mfConfig.name || (null == (_config_output = config.output) ? void 0 : _config_output.uniqueName);
    const chunkFileName = config.output.chunkFilename;
    if ('string' == typeof chunkFileName && uniqueName && !chunkFileName.includes(uniqueName)) {
        const suffix = `${encodeName(uniqueName)}-[contenthash].js`;
        config.output.chunkFilename = chunkFileName.replace('.js', suffix);
    }
    return config;
}
function createSSRREnvConfig(envConfig, mfConfig, ssrDir, rsbuildConfig, callerName) {
    var _ssrEnvConfig_output, _ssrEnvConfig_output_distPath, _ssrEnvConfig_output1, _rsbuildConfig_output_distPath, _rsbuildConfig_output;
    const ssrEnvConfig = {
        ...envConfig,
        tools: {
            rspack: (config, { environment })=>{
                if (environment.name !== SSR_ENV_NAME) return;
                patchSSRRspackConfig(config, mfConfig, ssrDir, callerName);
            }
        }
    };
    ssrEnvConfig.output = {
        ...ssrEnvConfig.output,
        target: 'node',
        distPath: {
            ...null == (_ssrEnvConfig_output = ssrEnvConfig.output) ? void 0 : _ssrEnvConfig_output.distPath,
            root: path.join((null == (_ssrEnvConfig_output1 = ssrEnvConfig.output) ? void 0 : null == (_ssrEnvConfig_output_distPath = _ssrEnvConfig_output1.distPath) ? void 0 : _ssrEnvConfig_output_distPath.root) || (null == (_rsbuildConfig_output = rsbuildConfig.output) ? void 0 : null == (_rsbuildConfig_output_distPath = _rsbuildConfig_output.distPath) ? void 0 : _rsbuildConfig_output_distPath.root) || '', ssrDir)
        },
        emitAssets: true
    };
    return ssrEnvConfig;
}
function createSSRMFConfig(mfConfig) {
    var _mfConfig_library;
    const ssrMFConfig = {
        ...mfConfig,
        exposes: {
            ...mfConfig.exposes
        },
        library: {
            ...mfConfig.library,
            name: mfConfig.name,
            type: (null == (_mfConfig_library = mfConfig.library) ? void 0 : _mfConfig_library.type) ?? 'commonjs-module'
        },
        dts: false,
        dev: false,
        runtimePlugins: [
            ...mfConfig.runtimePlugins || []
        ]
    };
    ssrMFConfig.runtimePlugins.push(resolve('@module-federation/node/runtimePlugin'));
    if (isDev()) ssrMFConfig.runtimePlugins.push(resolve('@module-federation/node/record-dynamic-remote-entry-hash-plugin'));
    return ssrMFConfig;
}
function isRegExp(target) {
    return util.types.isRegExp(target);
}
var __webpack_exports__DEFAULT_ASSET_PREFIX = "/";
export { SSR_DIR, SSR_ENV_NAME, addDataFetchExposes, autoDeleteSplitChunkCacheGroups, createSSRMFConfig, createSSRREnvConfig, isRegExp, patchSSRRspackConfig, setSSREnv, updateStatsAndManifest, __webpack_exports__DEFAULT_ASSET_PREFIX as DEFAULT_ASSET_PREFIX };
